# Семинары -- "КОМПЬЮТЕРНЫЕ ТЕХНОЛОГИИ"

## Семинар 1 -- "Основы языка C++"

**Подключение стандартной библиотеки:**
```cpp
#include <iostream>
using namespace std;
int main()
{
  cout << "Hello, world!" << endl;
  return 0;
}
```

Можно иначе:
```cpp
#include <iostream>
int main()
{
  std::cout << "Hello, world!" << endl;
  return 0;
}
```

**Переменные** - именованная область памяти, где хранится значение.

**Типы данных:** bool, char(1 байт), short, int, long, double, float

**Модификаторы (для целочисленных):**
signed -- знаковый
unsigned -- беззнаковый
const -- постоянный

#include <limits> ULLONG_MAX -- максимальное значение беззнакового

**Арифметические операторы**: =, ==, +, -, *, /, %

Множественное присваивание:
```cpp
a = b = c = 0
```

**Префиксный и постфиксный инкремент:**
```cpp
int x = 5;
int y = ++x; // изменить x, затем присвоить y = 6
```

```cpp
int z = 5;
int y = z++; // присвоить y = 5, затем увеличить z
```
**Цикл for**
```cpp
for (инициализация ; условия продолжения цикла ; итерация)
```

*Пример(таблица соответствия температур):*
```cpp
int up = 300, low = 0, step = 20;
for (int fahr = low; fahr <= up ; fahr+= step)
    {
        cout << fahr << "to" << 5 * (fahr - 32)/9 << endl;
    }
```
*Другие примеры*
Эквивалентные конструкции:
```cpp
for(;;)
    {
        i++;
        a *= i;
    }
```
```cpp
for (; i < 10; i++)
    a *= i;
```

```cpp
for (; i < 10; i++; a *= i)
```

**Ввод(аналог scanf)** -- cin >>

**Цикл while**
```cpp
    int fahr = low, up = 200, low = 0, step = 20;
    while (fahr <= up)
        {
            int cels = 5 * (fahr - 32) / 9;
            cout << fahr << "to" << cels;
            fahr = fahr + step;
        }
```

**Цикл do-while**
```cpp
do
{
    cin >> n;           // выполнить тело
} while ( n!= 7);       // проверить
```

**Оператор if-else**
```cpp
if (выражение)
    инструкция_1;
else
    инструкция_2;
```

Есть еще вложенные **if-else**

**Сокращенный if-else**
```cpp
max = x > y ? x : y;
abs = x >= 0 ? x : -x;
a = x > y || x * y <= z && !x ? func(x) : func(y) % 7;
 ```

**Оператор switch**
```cpp
switch(c)
    {
        case 1: ...
        ...
        default: ...
    }
```

**break и continue** лучше чем **goto**

### Функции

**Функция** -- обособленный участок кода, исполнение которого можно вызвать из любой части кода

```cpp
тип_результата func(список параметров)
    {
        декларация переменных;
        инструкции
        return ...;
    }
```

*Функция возведения в степень:*
```cpp
int power(int x, int n)
{
    int res = 1;
    for (int i = 0 : i < n ; i++)
        res *= x;
    return res;
}
```

Область видимости функции -- видна только  ниже объявления.
Нужны прототипы функций.

## Массивы и структуры
**Массив** -- набор однотипных элементов фиксированной длины.
Нельзя объединять в массив элементы разного типа.
Сообщений о выходе за рамки памяти нет.
```cpp
int a[10];
a[0] = -17 + a[3];
```

**Многомерные массивы**
```cpp
int a[3];
for (i = 0; i < 3; i ++)
    a[i] = 0;

int m[3][4]; В массиве 3 элемента, кажый из 3-х состоит из 4 элементов.
```
Инициализация:
```cpp
int a[3][4] = { {1,1,1,1}, ..., {3,3,3,3} }
```

**Передача массива в функцию**
Имя массива -- указатель на 1 байт 0-го элемента массива
```cpp
void read_array(int* arr, int n)
{
    for ( i = 0 ; i < n ; i++)
        cin >> arr[i];
}

void write_array(int* arr, int n)
{
    for ( i = 0 ; i < n ; i++)
        cout >> arr[i];
}
```

Двумерный массив:
```cpp
int m[5][5];

for (int i = 0 ; i < 5; i ++)
{
    for (int j = 0; j < 5; j ++)
        m[i][j] = i * 5 + j;
}
```

**Структуры данных**
```cpp
struct name_of_structure {
    int i;
    char c;
}
```

Слово *struct* можно опустить

У структуры могут быть **методы** -- фугкции внутри структуры и работающие со структурой

```cpp
struct Point {
    float x;
    float y;
    float abs()
    {
        return sqrt(x*x + y*y)
    }
}
```cpp

**Перегрузка функций**
**Переопределение операторов**
```cpp
struct Point {
    float x;
    float y;
}
Point p1 = {3,4}, p2 = {3,1}, p3;
p3.x = p1.x + p2.x
p3.y = p1.y + p2.y
```
а можно:
```cpp
Point operator+ ( Point a, Point b) {
    Point tmp = {a.x + b.x, a.y + b.y};
    return tmp;
}

Point p1 = {3,4}, p2 = {3,1};
Point s = p1 + p2
```

Можно определить еще и другие операторы: +,-, ==, = ...
Нельзя придумать новые операторы
